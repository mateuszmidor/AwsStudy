@startmindmap 00-diagram

title DynamoDB

<style>
mindmapDiagram {
  .trail {
    BackgroundColor Pink
  }
  .orange {
    BackgroundColor orange
  }
  .xray {
    BackgroundColor LightSkyBlue
  }
  .watch {
    BackgroundColor LightGreen
  }
}
</style>


*[#Orange] <b>DynamoDB
 * read/write capacity modes:\n*provisioned(default)\n** manually specify reads/writes per second\n**plan beforehand\n**pay for what you provisioned\n*on-demand mode\n**scales up/down automatically\n**no capacity planning needed\n**pay for what you used, but more than in provisioned mode\n*can change mode once pe 24 hours
  * Provisioned\n*table must have provisioned read and write capacity units\n*can setup auto-scaling\n*capacity can be exceeded temporarily using BurstCapacity\n**once BurstCapacity is consumed, you get:\n    "ProvisionedThroughputExceededException"
   * Write Capacity Units(WCU) - throughput for Write\n*1WCU = 1KB/s\n*4KB/s = 4WCU\n*4.5KB/s=5WCU (rounded up to 1KB!!!)
   * Read Capacity Units(RCU) - throughput for Read\n*Eventually Consistent Read(default) -\n immediate read after write can return stale data\n*Strongly Consistent Read - always fresh data\n**but consumes RCU x2 !!!\n*1RCU = 1 strongly consistent 4KB read/s\n*16KB/s strongly consistent = 4RCU\n*17KB/s strongly consistent = 5RCU(rounded up to 4KB!!!)\n*16KB/s eventually consistent = 2RCU
  * On-demand\n*no planning\n*no throttling, unlimited RCU and WCU\n*2.5x more expensive than provisioned mode
 * Partitions\n*data is stored on partitions\n*partitions live on specific servers\n*destination partition is based on hash of Partition Key
 * Throttling\n*if we exceed provisioned WCU or RCU,\n we get "ProvisionedThroughputExceededException"\n*reasons:\n**hot keys - one partition is selected more often that others\n**hot partition\n**very large items - RCU and WCU consumption depend on size!\n*solutions:\n**exponential backoff (handled by SDK)\n**better partition keys distribution - choose better keys\n**if RCU issue - DynamoDB Accelerator (DAX) may help
 * API
  * Write\n*PutItem-create or replace row with same PrimaryKey, consume WCUs\n*UpdateItem-create or replace item's attributes, used for Atomic Counters\n*ConditionalWrites-accept write/update/delete if conditions are met
  * Read\n*GetItem-read based on PrimaryKey - Hash or Hash+Range\n**Eventually Consistent by default, option to enable Strong Consistency\n**ProjectedExpression - only read some attributes of the item\n*Query - read many items (rows) of given PartitionKey\n*Scan\n**read entire table and filter data on client side (inefficient)\n**by reading entire table - consumes a lot of RCUs\n**can reduce the number of items using "Limit"\n**returns up to 1MB of data\n**for more data - use pagination\n**can be used with ProjectionExpressions and FilterExpressions\n*ParallelScan - faster than just Scan
   * Query\n*KeyConditionExpression\n**required PartitionKey(=)\n** optional SortKey(>, >=, <, <=, Between, Begins with)\n*FilterExpression - filtering after Query operation;\n      accepts only attributes other than Hash and Range\n*Query returns number of items specified in "Limit" or up to 1MB of data\n*Query can paginate data
  * Delete\n*DeleteItem - can delete items conditionally\n*DeleteTable - much faster than deleting items one by one
  * Batch operations\n*BatchWriteItem\n**up to 25 PutItem/DeleteItem in one call\n**up to 16MB/400KB per item in one call\n**can't update items\n*BatchGetItem\n**read from one or more tables\n**1oo items or 16MB of data
@endmindmap
